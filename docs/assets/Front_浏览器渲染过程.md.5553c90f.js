import{_ as o,o as e,c,O as d}from"./chunks/framework.0acdd879.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"doc","outline":"deep"},"headers":[],"relativePath":"front/浏览器渲染过程.md","filePath":"front/浏览器渲染过程.md"}'),t={name:"Front/浏览器渲染过程.md"},a=d('<h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h1 id="简单渲染前过程描述" tabindex="-1">简单渲染前过程描述 <a class="header-anchor" href="#简单渲染前过程描述" aria-label="Permalink to &quot;简单渲染前过程描述&quot;">​</a></h1><h2 id="大致流程" tabindex="-1">大致流程 <a class="header-anchor" href="#大致流程" aria-label="Permalink to &quot;大致流程&quot;">​</a></h2><ol><li>用户输入域名，DNS解析域名为IP地址</li><li>浏览器根据IP地址请求服务器</li><li>服务器响应HTTP请求，并返回数据给浏览器</li><li>浏览器开始渲染</li></ol><h2 id="具体细节" tabindex="-1">具体细节： <a class="header-anchor" href="#具体细节" aria-label="Permalink to &quot;具体细节：&quot;">​</a></h2><ol><li><p>当用户输入域名URL后，浏览器进程（一般一个<strong>标签页</strong>对应一个<strong>单独的进程</strong>，但是一些空白页会被合并为一个进程）中的<code>UI线程</code>会建立一个<code>网络线程</code>，<code>网络线程</code>会根据<code>DNS</code>对域名进行<strong>解析</strong>获取<code>IP</code>（如果用户输入的是一些关键字/本地文件路径，就会到对应的搜索引擎/本地文件）。得到<code>IP</code>后，浏览器的<code>SafeBrowsing</code>会对<code>IP</code>进行安全检查（是否在黑名单），如果判定为不安全会提供一个<text style="color:red;">禁止访问</text>的页面，如果安全将与服务器进行通信（TCP三次握手，返回响应报文）通知<code>UI线程</code>进行下一步工作。</p></li><li><p><code>UI线程</code>此时将新建一个<code>渲染进程</code>，并且通过<code>IPC</code>管道传输<code>HTML</code>文件给<code>渲染进程</code>的<code>主线程</code>，此时，正式开始渲染。</p></li></ol><h3 id="🏊‍♂️主线程" tabindex="-1">🏊‍♂️主线程 <a class="header-anchor" href="#🏊‍♂️主线程" aria-label="Permalink to &quot;🏊‍♂️主线程&quot;">​</a></h3><ol><li><p>在<code>主线程</code>中，会将<code>HTML</code>文件进行<strong>词法分析</strong>转义为<code>Token</code>，即<code>Tokenization</code>（标记化）</p></li><li><p>并且创建<code>DOM节点</code>，最后创建成<code>DOM</code>树</p><blockquote><p>上述 1,2 被称为HTML解析</p></blockquote></li><li><p>但解析过程中，可能遇到<code>&lt;link&gt;与&lt;style&gt;</code>，就会涉及到CSS的解析（为了提升解析效率，浏览器在解析前会启动一个<strong>预解析</strong>，会优先下载<code>css</code>与<code>js</code>的资源文件。当<code>CSS</code>文件还未下载的时候，主线程并不会<strong>阻塞</strong>，这是因为<code>CSS</code>的下载与解析是在<code>预解析</code>线程中执行的，CSS解析完成后将生成<code>CSSOM</code>树。</p><img src="https://s2.loli.net/2023/04/12/HK6W4eGIp7gSRd3.png" alt="img" style="zoom:50%;"></li><li><p>解析过程中，可能遇到<code>&lt;script&gt;</code>等标签，这就涉及到了<code>JS</code>的解析，而<code>JS</code>的解析会<strong>阻塞</strong>当前的<code>HTML</code>解析，在<code>JS</code>解释完毕后再继续，这是因为我们不清楚<code>JS</code>是否会操作<code>DOM</code>节点或者操作<code>CSS</code>节点。</p><blockquote><p>因此，我们需要注意JS的引入时间，一般JS的加载位置应该放在BODY标签的底部，或者使用<code>Defer</code>。</p></blockquote></li><li><p>此时，我们已经得到了解析好的<code>DOM</code>树与<code>CSSOM</code>树，此时进行<code>Computed Style</code>，得到一棵带有<strong>样式</strong>的<code>DOM</code></p></li><li><p>但是还不够，我们还需要得到<code>Layout</code>来获取每个节点的<strong>几何信息</strong>，通过这个计算过程后，我们将得到一棵带有页面<code>x,y坐标以及盒子尺寸</code>的<code>Layout Tree</code>，此时<code>Layout Tree</code>与我们真实能看到的内容是一一对应的了。</p><blockquote><p><code>Layout Tree</code>与<code>DOM</code>并非一一对应，其中不可视的<code>display: none</code>不会在<code>Layout Tree</code>上，而伪类元素(::before等)会挂载在<code>Layout Tree</code>的相应节点</p></blockquote></li><li><p>但是仍然不够，此时还需要注意，如果两个节点的位置大小有重合的话，我们无法确定哪个节点展示在前，哪个被覆盖，因此我们还需要确认各个节点的<code>绘制顺序</code>，即<code>分层</code>。</p></li><li><p>分层工作完成后,将生成绘制指令，将每个层单独<strong>生成</strong>绘制指令。==只是生成，并未执行==</p></li></ol><h3 id="🏊‍♀️合成线程" tabindex="-1">🏊‍♀️合成线程 <a class="header-anchor" href="#🏊‍♀️合成线程" aria-label="Permalink to &quot;🏊‍♀️合成线程&quot;">​</a></h3><ol start="9"><li><p>合成线程会先对图层进行分块处理得到<code>Tiles</code>（会从线程池获取<strong>栅格线程</strong>的帮助）</p></li><li><p>分块完成后，将进行<strong>光栅化</strong>阶段，这一过程会交付给GPU进程，最终得到位图。</p></li><li><p>最后，当所有的图块都被栅格化后，合成线程将生成一个个<strong>指引quad</strong>信息，并通过<code>IPC</code>给浏览器进程发送一个渲染帧，这个渲染帧最终将交由GPU进行显示，每当页面滚动的时候，合成线程都会交付另一个渲染帧给GPU来<code>更新页面</code>。</p><blockquote><p>指引会标识位图的位置，以及考虑旋转，缩放平移等信息，与<strong>渲染主线程无关</strong>。这就是为什么<code>transform</code>效率高的本质原因，以及不会引起<code>回流（重排）与重绘</code>阻塞渲染。</p></blockquote></li></ol><blockquote><h2 id="相关问题" tabindex="-1">相关问题 <a class="header-anchor" href="#相关问题" aria-label="Permalink to &quot;相关问题&quot;">​</a></h2><h3 id="_1-reflow-回流-重排" tabindex="-1">1. Reflow 回流/重排 <a class="header-anchor" href="#_1-reflow-回流-重排" aria-label="Permalink to &quot;1. Reflow 回流/重排&quot;">​</a></h3><p>​ 当进行影响<code>Layout Tree</code>的操作的时候，需要重新计算<code>Layout Tree</code>，而且为了避免连续的多次布局反复计算，浏览器会合并这些操作，当JS代码全部完成后再统一计算，改动属性造成的<code>Reflow</code>是异步完成的。也正因如此，JS获取布局属性的时候可能会无法获取到最新的布局信息。</p><h3 id="_2-repaint-重绘" tabindex="-1">2. Repaint 重绘 <a class="header-anchor" href="#_2-repaint-重绘" aria-label="Permalink to &quot;2. Repaint 重绘&quot;">​</a></h3><p>​ 重绘，重新绘制渲染树，一般不影响DOM树，不一定引起回流，而回流一定引起重绘。</p></blockquote>',11),l=[a];function r(i,n,s,p,h,u){return e(),c("div",null,l)}const S=o(t,[["render",r]]);export{g as __pageData,S as default};
