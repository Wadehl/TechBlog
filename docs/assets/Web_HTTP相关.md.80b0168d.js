import{_ as e,o,c as t,O as d}from"./chunks/framework.0acdd879.js";const l="/web.png",P=JSON.parse('{"title":"HTTP的建立","description":"","frontmatter":{"layout":"doc","outline":"deep"},"headers":[],"relativePath":"Web/HTTP相关.md","filePath":"Web/HTTP相关.md"}'),c={name:"Web/HTTP相关.md"},a=d('<h1 id="http的建立" tabindex="-1">HTTP的建立 <a class="header-anchor" href="#http的建立" aria-label="Permalink to &quot;HTTP的建立&quot;">​</a></h1><h2 id="_1-osi七层模型与tcp-ip四层模型" tabindex="-1">1. OSI七层模型与TCP/IP四层模型 <a class="header-anchor" href="#_1-osi七层模型与tcp-ip四层模型" aria-label="Permalink to &quot;1. OSI七层模型与TCP/IP四层模型&quot;">​</a></h2><table><thead><tr><th>OSI 七层模型</th><th>OSI 五层模型</th><th>TCP/IP四层模型</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>应用层</td></tr><tr><td>表示层</td><td>-</td><td>-</td></tr><tr><td>会话层</td><td>-</td><td>-</td></tr><tr><td>传输层</td><td>传输层</td><td>传输层</td></tr><tr><td>网络层</td><td>网络层</td><td>网络层</td></tr><tr><td>链路层</td><td>链路层</td><td>网络接口层</td></tr><tr><td>物理层</td><td>物理层</td><td>-</td></tr></tbody></table><p><img src="'+l+'" alt="img"></p><h2 id="_2-tcp握手协议-传输层、端对端" tabindex="-1">2. TCP握手协议（传输层、端对端） <a class="header-anchor" href="#_2-tcp握手协议-传输层、端对端" aria-label="Permalink to &quot;2. TCP握手协议（传输层、端对端）&quot;">​</a></h2><h3 id="_2-1-建立链接" tabindex="-1">2.1 建立链接 <a class="header-anchor" href="#_2-1-建立链接" aria-label="Permalink to &quot;2.1 建立链接&quot;">​</a></h3><ol><li>第一次握手</li></ol><p>​ 客户端主动打开链接，服务端被动打开。客户端发送<code>SYN</code>段（包含了客户端的初始序列号<code>seq=i</code>)</p><blockquote><p>如果半连接队列未满，服务器将该链接的状态变为<code>SYN_RCVD</code>，并把链接信息放入半连接队列中。</p><p>否则，服务器<strong>不会</strong>将链接状态改为<code>SYN_RCVD</code>，并且丢弃该链接。</p><p>（SYN flood攻击，DDOS攻击的一种，就是借助这种方式，不断发送<code>SYN</code>段但是不处理<code>SYN</code>+<code>ACK</code>段，使服务器崩溃。应对方式之一是让<code>syncookies=1</code>，即使半连接队列已满也可以接受非恶意攻击的客户端请求。）</p><p>(SYN flood攻击的方式其实也分两种，第一种，攻击方的客户端一直发送SYN，对于服务器回应的SYN+ACK什么也不做，不回应ACK, 第二种，攻击方的客户端发送SYN时，将源IP改为一个虚假的IP, 然后服务器将SYN+ACK发送到虚假的IP, 这样当然永远也得不到ACK的回应。)</p></blockquote><ol start="2"><li><p>第二次握手</p><p>服务端返回<code>SYN</code>+<code>ACK</code>段，且段中包含服务器的初始序列号<code>seq=j</code>，同时<code>ACK=i+1</code>，表示确认收到客户端的<code>seq</code>。</p><blockquote><p>此时，客户端从<code>SYN_SENT</code>变为<code>ESTABLISHED</code></p></blockquote></li><li><p>第三次握手</p><p>客户端返回<code>ACK</code>段，<code>ACK=j+1</code>，表示收到了服务器的初始序列号。</p><blockquote><p>服务器收到ACK后，如果全连接队列未满，服务器将该链接从<code>SYN_RCVD</code>变为<code>ESTABLISHED</code>，然后将该链接移出半连接队列，移入全连接队列。</p><p>若已满，会根据<code>tcp_abort_on_overflow</code>的值进行执行相应步骤。</p><ol><li><p>值为0</p><p>给客户端定时（二进制指数退让）发送SYN+ACK重新进行第二次握手。</p></li><li><p>值为1</p><p>重置连接（发送RST给客户端/忽略客户端传来的包，直到客户端认为异常断开）</p></li></ol></blockquote></li></ol><h3 id="_2-2-断开链接" tabindex="-1">2.2 断开链接 <a class="header-anchor" href="#_2-2-断开链接" aria-label="Permalink to &quot;2.2 断开链接&quot;">​</a></h3><ol><li><p>第一次</p><p>主动关闭方发送<code>FIN</code>与<code>seq=u</code>，此时<code>FIN</code>只是意味着客户端不再发送数据，并不意味着他不再接收数据，客户端进入<code>FIN_WAIT1</code>状态。</p></li><li><p>第二次</p><p>服务器给客户端发送<code>FIN</code>与<code>ACK= u+1</code>,<code>seq=v</code>，表示收到了客户端的<code>FIN</code>，此时服务器进入<code>CLOSE_WAIT</code>状态，客户端收到<code>ACK</code>后，进入<code>FIN_WAIT2</code>状态。</p></li><li><p>第三次</p><p>服务器确认发送完所有数据后，发送<code>FIN</code>与<code>seq=w</code>，<code>ACK= u+1</code>给客户端，之后进入<code>LAST_ACK</code>状态。</p></li><li><p>第四次</p><p>客户端收到服务器的<code>FIN</code>后，发送<code>ACK= w+1</code>, <code>seq= u+1</code>。</p></li></ol><h2 id="_3-状态码" tabindex="-1">3. 状态码 <a class="header-anchor" href="#_3-状态码" aria-label="Permalink to &quot;3. 状态码&quot;">​</a></h2><ol><li>1xx 信息性，代表请求已被接受，需要继续处理。</li><li>2xx 成功 <ul><li>200 请求已成功</li><li>201 表示资源已被新建</li><li>204 成功但是不返回内容</li></ul></li><li>3xx 重定向 <ul><li>301 资源永久转移</li><li>302 临时转移</li><li>304 缓存未过期，可以直接使用</li></ul></li><li>4xx 客户端错误 <ul><li>400 语法错误，服务器无法理解</li><li>401 身份认证错误</li><li>403 无权限访问</li><li>404 资源找不到</li><li>409 资源冲突</li></ul></li><li>5xx 服务端错误 <ul><li>500 未知错误（服务器源代码、数据库错误）</li><li>502 网关错误</li><li>503 服务器超载或维护</li><li>504 网关请求超时</li></ul></li></ol><h2 id="_4-版本差异" tabindex="-1">4. <a href="/webs/HTTP版本差异.html">版本差异</a> <a class="header-anchor" href="#_4-版本差异" aria-label="Permalink to &quot;4. [版本差异](/Web/HTTP版本差异)&quot;">​</a></h2><h2 id="_5-http缓存" tabindex="-1">5. <a href="/webs/HTTP缓存.html">HTTP缓存</a> <a class="header-anchor" href="#_5-http缓存" aria-label="Permalink to &quot;5. [HTTP缓存](/Web/HTTP缓存)&quot;">​</a></h2>',16),i=[a];function r(p,h,_,s,n,T){return o(),t("div",null,i)}const b=e(c,[["render",r]]);export{P as __pageData,b as default};
