import{_ as e,o,c as a,O as c}from"./chunks/framework.0acdd879.js";const d="/image-20230501214334004.png",i="/161233e6685e5e73tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",t="/image-20230501213045868.png",r="/image-20230501233831904.png",g=JSON.parse('{"title":"HTTP中的强缓存与协商缓存","description":"","frontmatter":{"layout":"doc","outline":"deep"},"headers":[],"relativePath":"Web/HTTP缓存.md","filePath":"Web/HTTP缓存.md"}'),l={name:"Web/HTTP缓存.md"},h=c('<h1 id="http中的强缓存与协商缓存" tabindex="-1">HTTP中的强缓存与协商缓存 <a class="header-anchor" href="#http中的强缓存与协商缓存" aria-label="Permalink to &quot;HTTP中的强缓存与协商缓存&quot;">​</a></h1><h2 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to &quot;浏览器缓存机制&quot;">​</a></h2><p>当我们在浏览器中输入一个网址的时候，浏览器会根据URL去请求服务器以获取所需要的数据资源，这一过程可能会导致页面有一段白屏时间，这是因为浏览器需要等待服务器返回数据，而这个过程中，浏览器是处于等待状态的，这样就会导致页面的白屏时间变长，用户体验变差。</p><p>因此，当我们需要提高用户体验的时候，我们就可以使用一些缓存技术，如：DNS缓存、CDN缓存、HTTP缓存等，良好的缓存策略可以降低重复资源的请求，降低服务器的开销，提升用户的页面加载速度。</p><h2 id="http缓存" tabindex="-1">HTTP缓存 <a class="header-anchor" href="#http缓存" aria-label="Permalink to &quot;HTTP缓存&quot;">​</a></h2><h3 id="基本原理" tabindex="-1">基本原理 <a class="header-anchor" href="#基本原理" aria-label="Permalink to &quot;基本原理&quot;">​</a></h3><p>HTTP缓存是指浏览器在第一次请求服务器资源时，服务器会在响应头中添加一些字段，这些字段会告诉浏览器如何处理这些资源，浏览器会根据这些字段来判断是否需要缓存这些资源，以及缓存多长时间，当浏览器再次请求这些资源时，会根据这些字段来判断是否需要使用缓存。</p><p>HTTP缓存分为强缓存和协商缓存，强缓存是指浏览器不需要发送请求到服务器，而是直接从本地缓存中获取资源，协商缓存是指浏览器会发送请求到服务器，由服务器来判断是否使用缓存。</p><h3 id="强缓存-🦸" tabindex="-1">强缓存 🦸 <a class="header-anchor" href="#强缓存-🦸" aria-label="Permalink to &quot;强缓存 🦸&quot;">​</a></h3><p>强缓存是指浏览器在第一次请求服务器资源时，服务器会在响应头中添加<code>Cache-Control</code>和<code>Expires</code>字段，这两个字段会告诉浏览器如何处理这些资源，浏览器会根据这些字段来判断是否需要缓存这些资源，以及缓存多长时间，当浏览器再次请求这些资源时，会根据这些字段来判断是否需要使用缓存。</p><h4 id="强缓存相关字段" tabindex="-1">强缓存相关字段 <a class="header-anchor" href="#强缓存相关字段" aria-label="Permalink to &quot;强缓存相关字段&quot;">​</a></h4><h5 id="_1-pragma" tabindex="-1">1. pragma <a class="header-anchor" href="#_1-pragma" aria-label="Permalink to &quot;1. pragma&quot;">​</a></h5><p><code>pragma</code>是HTTP/1.1之前遗留的通用首部字段，只有<code>no-cache</code>这一可选值，当<code>no-cache</code>存在时，一定不会命中强缓存。</p><h5 id="_2-cache-control" tabindex="-1">2. Cache-Control <a class="header-anchor" href="#_2-cache-control" aria-label="Permalink to &quot;2. Cache-Control&quot;">​</a></h5><p><code>Cache-Control</code>是HTTP/1.1中用来控制缓存的字段，它可以设置多个值，每个值之间用逗号隔开，常用的值有：</p><ul><li><code>public</code>：表示资源可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</li><li><code>private</code>：表示资源只能被发送请求的客户端缓存，不能被代理服务器（CDN）缓存。</li><li><code>no-cache</code>：表示资源可以被缓存，但是每次在使用缓存资源时，都需要向服务器发送请求，由服务器来判断是否使用缓存。</li><li><code>no-store</code>：表示资源不可以被缓存，每次都需要向服务器发送请求。</li><li><code>max-age</code>：表示资源可以被缓存的最大时间，单位为秒。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>&#39;no-cache&#39;并不意味着不可以进行缓存，而是每次在使用缓存资源时，都需要向服务器发送请求，由服务器来判断缓存是否有效，有效才会使用缓存（<code>协商缓存</code>） - &#39;no-store&#39;才表示不可以进行缓存</li><li><code>Chrome</code>强制刷新(<code>Ctrl+F5</code>)的实现方式为，在请求的首部添加<code>pragma: no-cache</code>与<code>cache-control: no-cache</code>实现</li></ul><p>​ <img src="'+d+'" alt="image-20230501214334004"></p><ul><li><code>max-age</code>的值为非0或设置了大于请求日期的<code>Expires</code>才可能命中强缓存，并且只有<code>cache-control</code>不存在<code>no-cache</code>/<code>no-store</code>以及<code>pragma</code>的时候，才会命中强缓存</li><li><code>max-age=0</code>的时候，与<code>cache-control: no-cache</code>效果类似</li></ul></div><h5 id="_3-expires" tabindex="-1">3. Expires <a class="header-anchor" href="#_3-expires" aria-label="Permalink to &quot;3. Expires&quot;">​</a></h5><p><code>Expires</code>是一个响应头字段，只有当<code>Expires</code>日期前的时候，HTTP缓存有效。并且当<code>cache-control</code>含<code>max-age</code>的时候，该字段被忽略。</p><h3 id="弱缓存-协商缓存-🕵️" tabindex="-1">弱缓存（协商缓存）🕵️ <a class="header-anchor" href="#弱缓存-协商缓存-🕵️" aria-label="Permalink to &quot;弱缓存（协商缓存）🕵️&quot;">​</a></h3><h4 id="弱缓存相关字段" tabindex="-1">弱缓存相关字段 <a class="header-anchor" href="#弱缓存相关字段" aria-label="Permalink to &quot;弱缓存相关字段&quot;">​</a></h4><h5 id="_1-last-modified-if-modified-since" tabindex="-1">1. Last-Modified/If-Modified-Since <a class="header-anchor" href="#_1-last-modified-if-modified-since" aria-label="Permalink to &quot;1. Last-Modified/If-Modified-Since&quot;">​</a></h5><p>​ <code>If-Modified-Since</code>是请求头中的一个字段（只能用于<code>GET</code>与<code>Head</code>请求），而<code>Last-Modified</code>是响应头中的一个字段。当带着<code>If-Modified-Since</code>的请求发送给服务器的时候，服务器将检查<code>Last-Modified</code>，如果<code>Last-Modified</code>早于或等于<code>If-Modified-Since</code>，则返回<code>304</code>响应，否则重新返回新的资源。</p><h5 id="_2-etag-if-none-match" tabindex="-1">2. ETag/If-None-Match <a class="header-anchor" href="#_2-etag-if-none-match" aria-label="Permalink to &quot;2. ETag/If-None-Match&quot;">​</a></h5><p>​ <code>If-None-Match</code>是请求头的一个字段，<code>ETag</code>是响应头的一个字段，它是根据资源的内容生成的一段<code>Hash</code>值。当带着<code>ETag</code>的请求发送到服务器的时候，服务器会寻找与之匹配的资源，如果有则返回<code>304</code>响应，否则返回<code>200</code>响应与新的资源。</p><div class="tip custom-block"><p class="custom-block-title">为什么需要ETag</p><ol><li>在没有修改文件内容的情况下，文件最后修改日期可能会变，会导致不必要的请求</li><li>当某些文件在==1秒==内进行了修改，<code>Last-Modified</code>可能监测不到</li><li>某些服务器无法精确获取到文件的修改日期</li></ol></div><h3 id="启发式缓存" tabindex="-1">启发式缓存 <a class="header-anchor" href="#启发式缓存" aria-label="Permalink to &quot;启发式缓存&quot;">​</a></h3><p>​ 当一个网络请求没有<code>expires</code>也没有<code>cache-control</code>，但是有<code>last-modified</code>的时候,浏览器会有一个默认的缓存策略:</p><p><code>(currentTime - Last-Modified) * 0.1</code></p><p><a href="https://paulcalvano.com/2018-03-14-http-heuristic-caching-missing-cache-control-and-expires-headers-explained/" target="_blank" rel="noreferrer">HTTP Heuristic Caching (Missing Cache-Control and Expires Headers) Explained</a></p><h3 id="缓存总流程" tabindex="-1">缓存总流程 <a class="header-anchor" href="#缓存总流程" aria-label="Permalink to &quot;缓存总流程&quot;">​</a></h3><p><img src="'+i+'" alt="整体流程"></p><details class="details custom-block"><summary>举个例子🌰</summary><p>第一次访问本页的时候：</p><p><img src="'+t+'" alt="第一次请求资源"></p><p>可以看到响应头有<code>Cache-Control: no-cache</code>以及<code>ETag</code>与<code>Last-Modified</code>，说明，此时为协商缓存。</p><p>第二次发送请求的时候，将会比对请求头中的<code>If-None-Match</code>与<code>If-Modified-Since</code>字段。</p><p><img src="'+r+'" alt="image-20230501233831904"></p><p>可以看到，此时<code>If-None-Match</code>与<code>ETag</code>是匹配的，<code>If-Modified-Since</code>也符合<code>Last-Modified</code>的要求，因此，服务器返回<code>304</code>响应，允许使用本地缓存。</p></details><div class="info custom-block"><p class="custom-block-title">附</p><h3 id="状态码区别" tabindex="-1">状态码区别 <a class="header-anchor" href="#状态码区别" aria-label="Permalink to &quot;状态码区别&quot;">​</a></h3><ul><li><code>200</code> 请求成功，服务器返回全新的资源</li><li><code>200</code> <code>from memory cache / from disk cache</code> 本地强缓存还在有效期，直接使用本地缓存。 其中，<code>from memory cache</code>表示页面刷新的时候，从内存中获取缓存，<code>from disk cache</code>表示标签页关闭后从磁盘获取缓存</li><li><code>304</code> 请求成功，服务器判断<code>ETag</code>与<code>Last-Modified</code>没有过期，告知浏览器使用本地缓存</li></ul><h3 id="缓存优先级" tabindex="-1">缓存优先级 <a class="header-anchor" href="#缓存优先级" aria-label="Permalink to &quot;缓存优先级&quot;">​</a></h3><p>​ <code>oragma &gt; cache-control &gt; expires &gt; Etag &gt; Last-Modified</code></p></div>',34),s=[h];function n(p,m,f,u,T,_){return o(),a("div",null,s)}const x=e(l,[["render",n]]);export{g as __pageData,x as default};
