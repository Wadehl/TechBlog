import{_ as s,c as e,o,aB as a}from"./chunks/framework.DeK-WOGe.js";const r=JSON.parse('{"title":"认证：Cookie、Session、Token、JWT（JSON Web Token）","description":"","frontmatter":{"layout":"doc","outline":"deep"},"headers":[],"relativePath":"front/前端权限认证方式.md","filePath":"front/前端权限认证方式.md"}'),n={name:"front/前端权限认证方式.md"};function l(t,i,k,h,d,c){return o(),e("div",null,[...i[0]||(i[0]=[a(`<h1 id="认证-cookie、session、token、jwt-json-web-token" tabindex="-1">认证：Cookie、Session、Token、JWT（JSON Web Token） <a class="header-anchor" href="#认证-cookie、session、token、jwt-json-web-token" aria-label="Permalink to &quot;认证：Cookie、Session、Token、JWT（JSON Web Token）&quot;">​</a></h1><h2 id="_1-cookie" tabindex="-1">1. Cookie <a class="header-anchor" href="#_1-cookie" aria-label="Permalink to &quot;1. Cookie&quot;">​</a></h2><ul><li>弥补HTTP没有状态的不足（无法判断两次HTTP请求是否来源于同一个用户）</li><li>存储在客户端中</li><li>不可跨域（依靠域名区分）</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取全部Cookie</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAllCookies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> all</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.cookie;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(all) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> all.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cookie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cookieArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookie.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;=&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cookies[cookieArr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> decodeURIComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cookieArr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookies;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_2-session" tabindex="-1">2. Session <a class="header-anchor" href="#_2-session" aria-label="Permalink to &quot;2. Session&quot;">​</a></h2><ul><li>弥补HTTP没有状态的不足（无法判断两次HTTP请求是否来源于同一个用户）</li><li>存储在服务端中</li><li>基于Cookie实现（SessionId）</li></ul><h4 id="请求流程" tabindex="-1">请求流程 <a class="header-anchor" href="#请求流程" aria-label="Permalink to &quot;请求流程&quot;">​</a></h4><ol><li>用户第一次请求服务器的时候，服务端会根据用户输入的信息生成对应的Session</li><li>服务端在本次请求返回Session对应的SessionId给客户端(Set-Cookie)</li><li>浏览器会将SessionId存入Cookie中，同时Cookie会记录SessionId对应的Domain</li><li>用户第二次访问服务器的时候，请求将自动将Cookie中的SessionId发送到服务端上，服务端根据该SessionId查找对应的用户信息，若找不到，说明Session不存在或者已过期，要求用户重新输入信息。</li></ol><blockquote><h3 id="session的一个使用场景" tabindex="-1">Session的一个使用场景 <a class="header-anchor" href="#session的一个使用场景" aria-label="Permalink to &quot;Session的一个使用场景&quot;">​</a></h3><ul><li>Nginx负载均衡的时候： <ul><li>登录在服务器1，请求个人信息在服务器2，那么登录后请求个人信息又需要重新登录。</li><li>用户将商品a加入购物车，而这个请求发送到服务器1，又将商品b加入购物车，这个请求发送到服务器2，最后订单结算，请求发送到服务器1，那么付款的时候，能看到的就只剩下商品a。</li></ul></li></ul><h3 id="使用session的时候需要考虑的问题" tabindex="-1">使用Session的时候需要考虑的问题 <a class="header-anchor" href="#使用session的时候需要考虑的问题" aria-label="Permalink to &quot;使用Session的时候需要考虑的问题&quot;">​</a></h3><ul><li>Session存储在服务器中的时候，如果用户使用量较大，需要定期清理过期的<code>Session</code></li><li>网站使用<strong>集群部署</strong>的时候，会遇到多台服务器共享<code>Session</code>的问题（即上面所述）</li><li>多个服务器共享Session，还需要考虑<code>Cookie</code>跨域的问题</li><li><code>SessionId</code>一般存储在<code>Cookie</code>中，但是如果浏览器禁止<code>Cookie</code>或不支持<code>Cookie</code>，一般把SessionId跟在URL参数后面重写URL（<code>Session</code>不一定需要<code>Cookie</code>）</li><li>移动端对<code>Cookie</code>的支持不是很好，<code>Session</code>一般依赖于<code>Cookie</code>，所以一般移动端应用<code>Token</code></li></ul><h3 id="关闭浏览器后session就永远消失了吗" tabindex="-1">关闭浏览器后Session就永远消失了吗 <a class="header-anchor" href="#关闭浏览器后session就永远消失了吗" aria-label="Permalink to &quot;关闭浏览器后Session就永远消失了吗&quot;">​</a></h3><p>​ <strong>不正确的</strong>。是因为大部分<code>Session</code>依赖于<code>Cookie</code>实现<code>SessionId</code>的保存，而关闭浏览器这个<code>Cookie</code>可能消失，这样再次链接服务器就会找不到原来的<code>Session</code>。如果服务器设置的<code>Cookie</code>通过硬盘或者其他手段改写<code>HTTP</code>请求头，把原来的<code>SessionId</code>发送给服务器，仍然能打开原来的<code>Session</code>。</p><p>​ 因为<strong>关闭浏览器并不会导致<code>Session</code>被删除，所以服务器才会给<code>Session</code>设置一个过期的时间，当<code>Session</code>到期后，服务器才会删除<code>Session</code>节省空间</strong>。</p></blockquote><blockquote><h3 id="session与cookie" tabindex="-1">Session与Cookie <a class="header-anchor" href="#session与cookie" aria-label="Permalink to &quot;Session与Cookie&quot;">​</a></h3><ul><li><strong>安全性</strong>：Session存在服务端更加安全，Cookie设置HttpOnly可以一定程度避免XSS攻击</li><li><strong>存取值类型</strong>：Cookie只支持字符串类型，Session可以为任意类型</li><li><strong>有效期</strong>：Cookie可以设置为长时间保存，Session一般在客户端关闭或者设定的较短期限到期</li><li><strong>存储大小与个数限制</strong>:Cookie一般单个限制为4KB，限定个数与浏览器有关；而Session一般不存在限制，但是如果访问较多的话会给服务端带来性能影响</li></ul></blockquote><h2 id="_3-token" tabindex="-1">3. Token <a class="header-anchor" href="#_3-token" aria-label="Permalink to &quot;3. Token&quot;">​</a></h2><p>一种简单的生成Token：</p><p>​ uuid(用户唯一标识)+时间戳+sign(hash处理token前几位生成的十六进制字符串)</p><p><strong>特点</strong>：</p><ul><li>服务端无状态化，可扩展性良好</li><li>支持移动端设备</li><li>安全</li><li>token完全由应用管理，可以避开同源策略</li></ul><h3 id="_3-1-access-token" tabindex="-1">3.1 Access Token <a class="header-anchor" href="#_3-1-access-token" aria-label="Permalink to &quot;3.1 Access Token&quot;">​</a></h3><ol><li>客户端发送用户名密码等验证信息</li><li>服务端收到请求后进行验证，验证通过后，根据登录凭证加密为Access Token后与数据一起返回给客户端</li><li>客户端收到Token后，一般存储到localStorage中</li><li>客户端再次发起请求时，把Token放在请求头中</li><li>服务端收到请求后，查询数据库信息验证Token，验证成功后返回数据</li></ol><h3 id="_3-2-refresh-token" tabindex="-1">3.2 Refresh Token <a class="header-anchor" href="#_3-2-refresh-token" aria-label="Permalink to &quot;3.2 Refresh Token&quot;">​</a></h3><p>AccessToken存在过期时间（服务端存在数据库内），当Access Token过期后，用户需要重新输入验证信息。为了方便用户，还有一个Refresh Token。</p><ol><li>客户端发送用户名密码等验证信息</li><li>服务端收到请求后进行验证，验证通过后，根据登录凭证加密为AccessToken与RefreshToken(RefreshToken过期时限&gt;AccessToken)后与数据一起返回给客户端</li><li>客户端收到Token后存放在本地(一般为localStorage)</li><li>当客户端发送请求的时候将Access Token传输到服务端，服务端进行校验与过期检查，如果没有过期则返回数据</li><li>如果AccessToken过期，服务端向客户端发送过期错误，此时客户端将RefreshToken发送到服务端进行检验</li><li>如果RefreshToken未过期，则发送新的Access Token与 Refresh Token给客户端；否则，客户端需要重新输入登录验证信息</li></ol><blockquote><h3 id="token与session" tabindex="-1">Token与Session <a class="header-anchor" href="#token与session" aria-label="Permalink to &quot;Token与Session&quot;">​</a></h3><ul><li>Session用于保持会话，使服务端状态化；而Token是访问资源（API）的一个凭证令牌，会使服务端无状态化</li><li>Token的安全性比Session要好，每个请求都会对签名解密，能够防止监听以及重复攻击，而Session必须依赖链路层保障通讯安全</li><li>二者不冲突，可以同时存在</li></ul></blockquote><blockquote><h3 id="为什么从cookie转到token" tabindex="-1">为什么从Cookie转到Token <a class="header-anchor" href="#为什么从cookie转到token" aria-label="Permalink to &quot;为什么从Cookie转到Token&quot;">​</a></h3><p>​ 原因在于之前，<code>JQuery</code>前端时代是前后端<strong>不分离</strong>的，后端在模板渲染前会判断路由是否有权限来决定是否跳转。登录的时候，后端只需要设置<code>SetCookie</code>这个响应头，<code>Cookie</code>就能够存储起来并且自动发送。</p><p>​ 但是现在的前后端分离，通常需要进行<strong>跨域</strong>操作，此时<code>Cookie</code>就有更多的限制了，因此我们更愿意使用手动管理权限的Token方式。</p></blockquote><h2 id="_4-jwt" tabindex="-1">4. JWT <a class="header-anchor" href="#_4-jwt" aria-label="Permalink to &quot;4. JWT&quot;">​</a></h2><p>JWT原理是在服务器认证后，生成一个JSON对象，发送给用户，这个JSON对象包含用户的信息，之后用户每次发送请求的时候，都需要携带上JWT，为了防止数据被篡改，服务器在生成对象的时候，会加上签名。</p><h3 id="_4-1-jwt的数据结构" tabindex="-1">4.1 JWT的数据结构 <a class="header-anchor" href="#_4-1-jwt的数据结构" aria-label="Permalink to &quot;4.1 JWT的数据结构&quot;">​</a></h3><p><code>Header.Payload.Signature</code>三部分用.链接</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="img" data-fancybox="gallery"></p><ul><li><p>Header</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;alg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;HS256&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;typ&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;JWT&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>alg</code>表示签名的算法<code>HMAC SHA256</code>，<code>typ</code>表示该token的类型，<code>JWT</code>统一为<code>JWT</code>。</p></li><li><p>Payload</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;iss (issuer)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;签发人&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;exp (expiration time)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;过期时间&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;sub (subject)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;主题&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;aud (audience)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;受众&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;nbf (Not Before)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;生效时间&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;iat (Issued At)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;签发时间&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;jti (JWT ID)&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;编号&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>除了上面7个官方字段外，还可以定义一些私有字段。</p></li><li><p>Signature</p><p>指定密钥(secret)后，按下面的公式生成。</p><p><code>signature = HMACSHA256(base64UrlEncode(Header)+&quot;.&quot;+(base64UrlEncode(Payload), secret)</code></p></li><li><p>BASE64URL算法</p><p>由于<code>JWT</code>作为令牌可能需要放在URL中，因为<code>+</code>、<code>/</code>、<code>=</code>在URL中有特殊的含义，所以要被替换掉，具体算法: <code>=</code>省略、<code>+</code>换位<code>-</code>，<code>/</code>替换为<code>_</code>。</p></li></ul><h3 id="_4-2-jwt的使用" tabindex="-1">4.2 JWT的使用 <a class="header-anchor" href="#_4-2-jwt的使用" aria-label="Permalink to &quot;4.2 JWT的使用&quot;">​</a></h3><ol><li><p>当客户端收到服务端返回的<code>JWT</code>的时候，可以存储在<code>Cookie</code>或<code>localStorage</code>中，在之后的每一次请求都需要带上<code>JWT</code>。当<code>JWT</code>在<code>Cookie</code>中的时候将自动发送（不允许跨域），所以一般会放在HTTP的请求头<code>Authorization</code>中。</p><p>一种使用方法：<code>Authorization: Bearer + &#39;JWT&#39;</code>(调用OpenAI API的时候就是将api_key放在请求头中)</p><p>另一种：跨域的时候，<code>JWT</code>放在<code>POST</code>请求的BODY中。</p></li></ol><h3 id="_4-3-jwt的特点" tabindex="-1">4.3 JWT的特点 <a class="header-anchor" href="#_4-3-jwt的特点" aria-label="Permalink to &quot;4.3 JWT的特点&quot;">​</a></h3><ol><li><code>JWT</code>默认不加密，但是可以生成原始<code>Token</code>后，使用密钥进行加密。</li><li><code>JWT</code>不加密的时候，由于里面的数据是可以被解码的,可以被直接获取，所以不应该在<code>JWT</code>内写入秘密数据,并且永远使用<strong>强密码哈希算法</strong>处理密码。</li><li><code>JWT</code>除了用于认证外，也可以用于信息的交换，可以减少数据库的查询次数。</li><li><code>JWT</code>的最大缺点在于，服务端并不会保存<code>Session</code>信息，因此无法在过程中废除<code>Token</code>或者更改<code>JWT</code>的权限。就是说，<code>JWT</code>一旦签发，在到期前都始终有效，除非服务器部署额外的逻辑。</li><li><code>JWT</code>本身包含了认证信息，如果泄露，那么任何人都可以获取该令牌的权限。为了减少盗用，<code>JWT</code>的有效期一般被设置的很短，对于一些重要的信息，使用的时候应该再次对用户认证。</li><li>为了减少盗用，<code>JWT</code>不应该使用<code>HTTP</code>传输，而是应该使用<code>HTTPS</code>。</li></ol><blockquote><h3 id="token与jwt的区别" tabindex="-1">TOKEN与JWT的区别 <a class="header-anchor" href="#token与jwt的区别" aria-label="Permalink to &quot;TOKEN与JWT的区别&quot;">​</a></h3><ul><li>相同： <ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都使服务器无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上的受保护的资源</li></ul></li><li>不同： <ul><li>Token：服务端验证客户端发送的Token的时候，还需要查询数据库获取用户的信息，并且验证Token是否有效。</li><li>JWT：Payload与Token加密后存储在客户端中，服务端只需要使用密钥解密并检验（JWT自己实现）即可，不需要或较少查询数据库，因为JWT包含了用户信息与加密的数据。</li></ul></li></ul></blockquote>`,33)])])}const u=s(n,[["render",l]]);export{r as __pageData,u as default};
