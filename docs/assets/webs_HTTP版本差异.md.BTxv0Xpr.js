import{_ as e,c as o,o as t,aB as r}from"./chunks/framework.DeK-WOGe.js";const P=JSON.parse('{"title":"HTTP版本差异","description":"","frontmatter":{"layout":"doc","outline":"deep"},"headers":[],"relativePath":"webs/HTTP版本差异.md","filePath":"webs/HTTP版本差异.md"}'),n={name:"webs/HTTP版本差异.md"};function i(l,a,s,h,d,T){return t(),o("div",null,[...a[0]||(a[0]=[r('<h1 id="http版本差异" tabindex="-1">HTTP版本差异 <a class="header-anchor" href="#http版本差异" aria-label="Permalink to &quot;HTTP版本差异&quot;">​</a></h1><h2 id="http-1-0" tabindex="-1">HTTP 1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP 1.0&quot;">​</a></h2><p>1.0的HTTP是一个无连接、无状态的<strong>应用层</strong>协议。因此客户端每次请求服务器都需要建立一个TCP链接，服务器处理完TCP立即断开（无连接），服务器也不会记录每次的请求（无状态）。</p><blockquote><p>无状态可以使用<code>Cookie</code>与<code>Session</code>来实现身份认证与状态记录（状态化）。</p></blockquote><h4 id="问题" tabindex="-1">问题： <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题：&quot;">​</a></h4><ul><li><h6 id="无法实现连接复用" tabindex="-1">无法实现连接复用 <a class="header-anchor" href="#无法实现连接复用" aria-label="Permalink to &quot;无法实现连接复用&quot;">​</a></h6></li></ul><p>​ 每次发送请求后，都需要进行一次TCP连接，TCP的连接与释放过程消耗很多资源，这种<strong>无连接</strong>特性会导致网络<strong>复用率</strong>变低。</p><ul><li><h6 id="队头阻塞" tabindex="-1">队头阻塞 <a class="header-anchor" href="#队头阻塞" aria-label="Permalink to &quot;队头阻塞&quot;">​</a></h6></li></ul><p>​ 由于HTTP 1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求将一直阻塞。</p><h2 id="http-1-1" tabindex="-1">HTTP 1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP 1.1&quot;">​</a></h2><h3 id="长连接" tabindex="-1">长连接 <a class="header-anchor" href="#长连接" aria-label="Permalink to &quot;长连接&quot;">​</a></h3><p>HTTP 1.1解决了<strong>连接复用</strong>的问题。HTTP 1.1增加了<code>Connection</code>字段，通过设置<strong>Keep-Alive</strong>使得HTTP连接能够连接不断，避免客户端与服务器多次建立与释放TCP连接，提高了网络的复用率。</p><p>当客户端需要关闭连接的时候，可以在请求头的<code>Connection</code>设为<code>false</code>告知服务器关闭。</p><h3 id="管道化" tabindex="-1">管道化 <a class="header-anchor" href="#管道化" aria-label="Permalink to &quot;管道化&quot;">​</a></h3><p>基于长连接实现，客户端能够发送多个请求，但是服务器必须按照请求的顺序依次回应相应的结果，即：让队列从客户端的请求队列迁移到了服务器的响应队列，但是仍然<strong>没有</strong>解决队头阻塞的问题。</p><h2 id="http-2-0" tabindex="-1">HTTP 2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP 2.0&quot;">​</a></h2><h3 id="二进制分帧" tabindex="-1">二进制分帧 <a class="header-anchor" href="#二进制分帧" aria-label="Permalink to &quot;二进制分帧&quot;">​</a></h3><p>HTTP 2.0通过在应用层与传输层之间增加了一个二进制分帧层，突破了HTTP 1.0的性能限制，改进了传输性能。</p><h3 id="多路复用" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用" aria-label="Permalink to &quot;多路复用&quot;">​</a></h3><ul><li><strong>流</strong>：已建立连接上的双向自己流。</li><li><strong>消息</strong>：与逻辑消息对应的完整的一系列数据帧。</li><li><strong>帧（frame）</strong>：HTTP 2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流（stream_id）</li></ul><p>每个数据流以消息的形式发送，而消息由一个或者多个帧组成。帧可以<strong>乱序</strong>发送，然后依赖<strong>流标识符</strong>重新封装。</p><p>并且HTTP 2.0的数据流可以设置<strong>优先级</strong>与<strong>依赖</strong>。</p><h3 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h3><p>在HTTP 1.X中，头部源数据都是以纯文本的形式发送的，会给每个请求头增加较多字节的负荷（Cookie），HTTP 2.0要求客户端与服务器都缓存一张<code>Header_Files</code>表，将<code>Header</code>进行编码压缩，避免了重复<code>Header</code>的传输，减小了传输的负荷。</p><h3 id="服务器推送" tabindex="-1">服务器推送 <a class="header-anchor" href="#服务器推送" aria-label="Permalink to &quot;服务器推送&quot;">​</a></h3><p>即客户端发送一次请求，服务器会主动将所需要的资源一次性推送给客户端。eg: 客户端请求一个index.html资源，服务器将在一次请求内将所有所需的index.css, index.js等资源返回给客户。</p><blockquote><p>这里的问题在于当用户误触到某个链接的时候，由于服务器推送机制，用户会一次性获取非常多不必要的资源，这种可能会造成DDoS攻击的实现。</p></blockquote><h2 id="http-3-0" tabindex="-1">HTTP 3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP 3.0&quot;">​</a></h2><p>HTTP 2.0成功解决了头部阻塞的问题，但是这里解决的只是应用层的头部阻塞，在传输层的TCP中，出现丢包的情况整个TCP都要等待重传，即<strong>传输层的头部阻塞并没有被解决</strong>，而修改TCP协议是不可能的（TCP协议由操作系统负责）。</p><h3 id="整合" tabindex="-1">整合 <a class="header-anchor" href="#整合" aria-label="Permalink to &quot;整合&quot;">​</a></h3><p>HTTP 2.0默认使用TLS加密，那么除了TCP握手外，还需要建立TLS握手，这样需要消耗非常多的资源（即使TLS 1.3较TLS 1.2已做了优化）。在HTTP 3.0中，TCP握手与TLS握手整合到了一起。即<strong>0-RTT</strong>连接。</p><h3 id="quic-udp" tabindex="-1">QUIC + UDP <a class="header-anchor" href="#quic-udp" aria-label="Permalink to &quot;QUIC + UDP&quot;">​</a></h3><p>QUIC基于UDP，一个连接上的多个流没有依赖，即使丢包只需要重新发送丢失的包即可，不需要重传整个连接，实现了<strong>多路复用</strong>。</p><p>QUIC的帧中包含了<code>Connection_Id</code>字段，QUIC是通过该段识别连接的，而TCP是基于IP识别连接的，那么当网络环境变化的时候，<code>Connection_Id</code>并不会改变，能够迅速实现重连，能够提供<strong>更好的移动端表现</strong>。</p><p>QUIC除了部分报文外，报文头部与报文BODY都经过加密，有效<strong>降低了安全风险</strong>。</p><p><strong>向前纠错</strong>，每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p>',36)])])}const p=e(n,[["render",i]]);export{P as __pageData,p as default};
